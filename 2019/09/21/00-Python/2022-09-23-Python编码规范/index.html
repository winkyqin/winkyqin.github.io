<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Python编码规范 | Qin Blog</title><meta name="keywords" content="Python 编码规范"><meta name="author" content="WinkyQin"><meta name="copyright" content="WinkyQin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python编码规范google python编码规范参考PEP 8 - Python 代码风格指南 Introduction - 简介 A Foolish Consistency is the Hobgoblin of Little Minds - 愚蠢的一致性是小心灵的大地精 Code lay-out - 代码布局 Indentation - 缩进 Tabs or Spaces? - A 罩杯">
<meta property="og:type" content="article">
<meta property="og:title" content="Python编码规范">
<meta property="og:url" content="http://winkyqin.com/2019/09/21/00-Python/2022-09-23-Python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/index.html">
<meta property="og:site_name" content="Qin Blog">
<meta property="og:description" content="Python编码规范google python编码规范参考PEP 8 - Python 代码风格指南 Introduction - 简介 A Foolish Consistency is the Hobgoblin of Little Minds - 愚蠢的一致性是小心灵的大地精 Code lay-out - 代码布局 Indentation - 缩进 Tabs or Spaces? - A 罩杯">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2019-09-20T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-29T03:41:28.995Z">
<meta property="article:author" content="WinkyQin">
<meta property="article:tag" content="Python 编码规范">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://winkyqin.com/2019/09/21/00-Python/2022-09-23-Python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-29 11:41:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">199</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Qin Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python编码规范</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-09-20T16:00:00.000Z" title="发表于 2019-09-21 00:00:00">2019-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-29T03:41:28.995Z" title="更新于 2022-09-29 11:41:28">2022-09-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Python编码规范"><a href="#Python编码规范" class="headerlink" title="Python编码规范"></a>Python编码规范</h1><h2 id="google-python编码规范参考"><a href="#google-python编码规范参考" class="headerlink" title="google python编码规范参考"></a><a target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/">google python编码规范参考</a></h2><h2 id="PEP-8-Python-代码风格指南"><a href="#PEP-8-Python-代码风格指南" class="headerlink" title="PEP 8 - Python 代码风格指南"></a>PEP 8 - Python 代码风格指南</h2><ul>
<li><a href="#1">Introduction - 简介</a></li>
<li><a href="#2">A Foolish Consistency is the Hobgoblin of Little Minds - 愚蠢的一致性是小心灵的大地精</a></li>
<li><a href="#3">Code lay-out - 代码布局</a><ul>
<li><a href="#3.1">Indentation - 缩进</a></li>
<li><a href="#3.2">Tabs or Spaces? - A 罩杯还是 E 罩杯 ？</a></li>
<li><a href="#3.3">Maximum Line Length - 代码行最大长度</a></li>
<li><a href="#3.4">Should a line break before or after a binary operator? - 在二元运算符之前还是之后断行？</a></li>
<li><a href="#3.5">Blank Lines - 空行</a></li>
<li><a href="#3.6">Source File Encoding - 源文件编码</a></li>
<li><a href="#3.7">Imports - 模块导入</a></li>
<li><a href="#3.8">Module level dunder names - 模块级 dunder 名称</a></li>
</ul>
</li>
<li><a href="#4">String Quotes - 字符串引号</a></li>
<li><a href="#5">Whitespace in Expressions and Statements - 表达式和语句中的空格</a><ul>
<li><a href="#5.1">Pet Peeves - 心理藏的小烦恼</a></li>
<li><a href="#5.2">Other Recommendations - 其他建议</a></li>
</ul>
</li>
<li><a href="#6">When to use trailing commas - 何时使用逗号结尾</a></li>
<li><a href="#7">Comments - 注释</a><ul>
<li><a href="#7.1">Block Comments - 块注释</a></li>
<li><a href="#7.2">Inline Comments - 行注释</a></li>
<li><a href="#7.3">Documentation Strings - 文档字符串</a></li>
</ul>
</li>
<li><a href="#8">Naming Conventions - 命名约定</a><ul>
<li><a href="#8.1">Overriding Principle - 圣经戒律</a></li>
<li><a href="#8.2">Descriptive: Naming Styles - 描述性: 命名风格</a></li>
<li><a href="#8.3">Prescriptive: Naming Conventions - 规定性: 命名习惯</a><ul>
<li><a href="#8.3.1">Names to Avoid - 避免的命名</a></li>
<li><a href="#8.3.2">Package and Module Names - 包和模块命名</a></li>
<li><a href="#8.3.3">Class Names - 类名</a></li>
<li><a href="#8.3.4">Type variable names - 类型变量名</a></li>
<li><a href="#8.3.5">Exception Names - 异常名</a></li>
<li><a href="#8.3.6">Global Variable Names - 全局变量名</a></li>
<li><a href="#8.3.7">Function Names - 函数名</a></li>
<li><a href="#8.3.8">Function and method arguments - 函数和方法参数</a></li>
<li><a href="#8.3.9">Method Names and Instance Variables - 方法名和实例变量</a></li>
<li><a href="#8.3.10">Constants - 常量</a></li>
<li><a href="#8.3.11">Designing for inheritance - 继承设计</a></li>
<li><a href="#8.3.12">Public and internal interfaces - 公共和内部接口</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1">简介</h2>

<p>很多项目都有自己独有的编码风格。<br>如果和本文规则发生任何冲突，优先与项目级别的代码风格保持一致。</p>
<!--
美其名曰：入乡随俗，Do what Romans do in Rome，到罗马咱就烤马肉吃。-->

<!--<h2 id="2">愚蠢的一致性是小心灵的大地精</h2>

代码风格一致性当然重要，想象一下空姐的制服诱惑，是不是赏心悦目呢。但也要有自己的主观判断。

例如以下场景：

1、遵循此风格写的一小片代码看起来和项目内其他代码格格不入，看到就想抠出来喂猪，人人见而曰日之。

2、遵循此风格后和其他 python 版本不兼容，甚至出现错误，这就尴尬了。

3、遵循此风格中的某些条目使代码更不易读，简单说就是丑。-->

<h2 id="3">代码布局</h2>

<h3 id="3.1">缩进</h3>

<p>一个缩进级别四个空格。</p>
<ul>
<li>连续行使用两种方式使封装元素成为一行：括号内垂直隐式连接 &amp; 悬挂式缩进。 使用悬挂式缩进应该注意第一行不应该有参数，连续行要使用进一步的缩进来区分。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 括号内隐式连接，垂直对齐</span></span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 悬挂缩进，进一步缩进区分其他语句</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_function_name</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        var_one, var_two, var_three,</span></span></span><br><span class="line"><span class="function"><span class="params">        var_four</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(var_one)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 悬挂缩进，一般是四个空格，但非必须</span></span><br><span class="line">foo = long_function_name(</span><br><span class="line">    var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 括号内隐式连接，没有垂直对齐时，第一行的参数被禁止</span></span><br><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">    var_three, var_four)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 悬挂缩进，需要进一步的缩进区分其他行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_function_name</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    var_one, var_two, var_three,</span></span></span><br><span class="line"><span class="function"><span class="params">    var_four</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(var_one)</span><br></pre></td></tr></table></figure>

<ul>
<li>当 if 语句过长时，可选的处理方式，但不限于此：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用额外缩进</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span></span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加注释区分，支持语法高亮</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing <span class="keyword">and</span></span><br><span class="line">    that_is_another_thing):</span><br><span class="line">    <span class="comment"># Since both conditions are true, we can frobnicate.</span></span><br><span class="line">    do_something()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 条件连续行额外缩进</span></span><br><span class="line"><span class="keyword">if</span> (this_is_one_thing</span><br><span class="line">        <span class="keyword">and</span> that_is_another_thing):</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure>

<ul>
<li>当闭环括号内元素跨行时，可以采用以下方式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    ]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">]</span><br><span class="line">result = some_function_that_takes_arguments(</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3.2">A 罩杯还是 E 罩杯 ？</h3>

<p>A 罩杯。</p>
<p>Python 3 不允许 tab 和 space 混用，同时混用了 tab 和 space 的 Python 2 代码应该被转换为仅使用 space。  </p>
<h3 id="3.3">代码行最大长度</h3>

<p>将所有行限制为最多79个字符。</p>
<p>对于具有较少结构限制（文档字符串或注释）的长文本块，行长度应限制为72个字符。</p>
<p>当然了，不要问为啥非得是 79,72。我们要兼顾非洲大陆人民的生活。代码是全世界的。</p>
<p>反斜杠有时可能仍然要用。 例如，又多又长的 with - 语句不能使用隐式连接，这时反斜杠是可以接受的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/some/file/you/want/to/read&#x27;</span>) <span class="keyword">as</span> file_1, \</span><br><span class="line">     <span class="built_in">open</span>(<span class="string">&#x27;/path/to/some/file/being/written&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_2:</span><br><span class="line">    file_2.write(file_1.read())</span><br></pre></td></tr></table></figure>

<p>assert 语句也是如此。</p>
<h3 id="3.4">在二元运算符之前还是之后断行?</h3>

<p>算法和程序设计技术先驱，计算机排版系统 TEX 和 METAFONT 的发明者 Donald Knuth，推荐使用以下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是： easy to match operators with operands</span></span><br><span class="line">income = (gross_wages</span><br><span class="line">          + taxable_interest</span><br><span class="line">          + (dividends - qualified_dividends)</span><br><span class="line">          - ira_deduction</span><br><span class="line">          - student_loan_interest)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">只要保持本地一致性，在二元运算符之前和之后断开都是允许的，但是新的 Python 代码推荐使用 Knuth 形式。  </span><br><span class="line"></span><br><span class="line">&lt;h3 id=&quot;3.5&quot;&gt;空行&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">顶层函数和类定义间使用两个空行。</span><br><span class="line"></span><br><span class="line">类内方法定义间使用一个空行。</span><br><span class="line"></span><br><span class="line">不同函数组之间使用两个空行隔离。</span><br><span class="line"></span><br><span class="line">总之，空行的作用就是隔离不同函数类等，使层次分明。</span><br><span class="line"></span><br><span class="line">&lt;h3 id=&quot;3.6&quot;&gt;源文件编码&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">Python <span class="number">2</span> 默认ASCII，Python <span class="number">3</span> 默认UTF-<span class="number">8</span>。</span><br><span class="line"></span><br><span class="line">使用 ASCII 的 Python <span class="number">2</span> 源文件或使用 UTF-<span class="number">8</span> 的 Python <span class="number">3</span> 源文件不应该有编码声明。</span><br><span class="line"></span><br><span class="line">源文件最好只使用 ASCII 字符，即使是蹩脚的 Chinglish 亦可，家和万事兴。</span><br><span class="line"></span><br><span class="line">&lt;h3 id=&quot;3.7&quot;&gt;模块导入&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line">是：</span><br><span class="line">    <span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line">    <span class="keyword">import</span> sys, os</span><br></pre></td></tr></table></figure>

<p>模块导入总是位于文件顶部，在模块注释和文档字符串之后，模块全局变量和常量之前。</p>
<p>导入应该按照以下顺序分组，不同组间用空行隔离。</p>
<ul>
<li>标准库 imports  </li>
<li>相关第三方 imports  </li>
<li>本地特定应用／库 imports  </li>
</ul>
<p>推荐使用绝对导入，标准库代码应总是使用绝对导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mypkg.sibling</span><br><span class="line"><span class="keyword">from</span> mypkg <span class="keyword">import</span> sibling</span><br><span class="line"><span class="keyword">from</span> mypkg.sibling <span class="keyword">import</span> example</span><br></pre></td></tr></table></figure>

<p>在包结构比较复杂时，可以使用相对导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> sibling</span><br><span class="line"><span class="keyword">from</span> .sibling <span class="keyword">import</span> example</span><br></pre></td></tr></table></figure>

<p>在 Python 3 中，相对导入已经被删除，禁止使用。</p>
<p>类导入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myclass <span class="keyword">import</span> MyClass</span><br><span class="line"><span class="keyword">from</span> foo.bar.yourclass <span class="keyword">import</span> YourClass</span><br></pre></td></tr></table></figure>

<p>如果这种方式导致了本地命名冲突，可以使用以下方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myclass</span><br><span class="line"><span class="keyword">import</span> foo.bar.yourclass</span><br></pre></td></tr></table></figure>
<p>然后使用 myclass.MyClass 和 foo.bar.yourclass.YourClass。</p>
<p>请不要使用以下方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt;module&gt; <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<h3 id="3.8">模块级别 dunder 名称</h3>

<p>模块级别 “dunders”(即具有两个前导和两个后缀下划线的名称)，例如 __all__，__author__，__version__ 等应放在模块 docstring 之后，但在任何 import 语句之前，但是除了 __future__ 导入。 Python 强制 future-imports 必须在除了 docstrings 之外的任何其他代码之前出现在模块中。  <br>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;This is the example module.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This module does stuff.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> barry_as_FLUFL</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">__version__ = <span class="string">&#x27;0.1&#x27;</span></span><br><span class="line">__author__ = <span class="string">&#x27;Cardinal Biggles&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>

<h2 id="4">字符串引号</h2>
在 Python 中，单引号和双引号是等价的，只需要坚持使用一种并保持一致即可。
在双引号中使用单引号，单引号中使用双引号。三引号中使用双引号。

<h2 id="5">表达式和语句中的空格<h2/>

<h3 id="5.1">心理藏的小烦恼</h3>

<p>在以下场景避免不必要的空格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">是： spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;)</span><br><span class="line">否： spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125; )</span><br><span class="line"></span><br><span class="line">是： foo = (<span class="number">0</span>,)</span><br><span class="line">否： bar = (<span class="number">0</span>, )</span><br><span class="line"></span><br><span class="line">是： <span class="keyword">if</span> x == <span class="number">4</span>: <span class="built_in">print</span> x, y; x, y = y, x</span><br><span class="line">否： <span class="keyword">if</span> x == <span class="number">4</span> : <span class="built_in">print</span> x , y ; x , y = y , x</span><br><span class="line"></span><br><span class="line">是：</span><br><span class="line">    ham[<span class="number">1</span>:<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span>:<span class="number">3</span>], ham[:<span class="number">9</span>:<span class="number">3</span>], ham[<span class="number">1</span>::<span class="number">3</span>], ham[<span class="number">1</span>:<span class="number">9</span>:]</span><br><span class="line">    ham[lower:upper], ham[lower:upper:], ham[lower::step]</span><br><span class="line">    ham[lower+offset : upper+offset]</span><br><span class="line">    ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]</span><br><span class="line">    ham[lower + offset : upper + offset]</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line">    ham[lower + offset:upper + offset]</span><br><span class="line">    ham[<span class="number">1</span>: <span class="number">9</span>], ham[<span class="number">1</span> :<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span> :<span class="number">3</span>]</span><br><span class="line">    ham[lower : : upper]</span><br><span class="line">    ham[ : upper]</span><br><span class="line">    </span><br><span class="line">是： spam(<span class="number">1</span>)</span><br><span class="line">否： spam (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">是： dct[<span class="string">&#x27;key&#x27;</span>] = lst[index]</span><br><span class="line">否： dct [<span class="string">&#x27;key&#x27;</span>] = lst [index]</span><br><span class="line"></span><br><span class="line">是：</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    y = <span class="number">2</span></span><br><span class="line">    long_variable = <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">否：</span><br><span class="line">    x             = <span class="number">1</span></span><br><span class="line">    y             = <span class="number">2</span></span><br><span class="line">    long_variable = <span class="number">3</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="5.2">其他建议</h3>

<p>在任何地方避免使用尾随空格。</p>
<p>在二元运算符周围使用空格：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    submitted += <span class="number">1</span></span><br><span class="line">    x = x*<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    hypot2 = x*x + y*y</span><br><span class="line">    c = (a+b) * (a-b)</span><br><span class="line">    </span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    i=i+<span class="number">1</span></span><br><span class="line">    submitted +=<span class="number">1</span></span><br><span class="line">    x = x * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    hypot2 = x * x + y * y</span><br><span class="line">    c = (a + b) * (a - b)</span><br></pre></td></tr></table></figure>
<p>表示关键字参数或默认参数值时，不要使用空格：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">complex</span>(<span class="params">real, imag=<span class="number">0.0</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> magic(r=real, i=imag)</span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">complex</span>(<span class="params">real, imag = <span class="number">0.0</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> magic(r = real, i = imag)</span><br></pre></td></tr></table></figure>
<p>函数注解的场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>: AnyStr</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">munge</span>() -&gt; AnyStr:</span> ...</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>:AnyStr</span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">munge</span>()-&gt;PosInt:</span> ...</span><br></pre></td></tr></table></figure>

<p>当参数注释和默认值共存时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params">sep: AnyStr = <span class="literal">None</span></span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>: AnyStr, sep: AnyStr = <span class="literal">None</span>, limit=<span class="number">1000</span></span>):</span> ...</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>: AnyStr=<span class="literal">None</span></span>):</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">munge</span>(<span class="params"><span class="built_in">input</span>: AnyStr, limit = <span class="number">1000</span></span>):</span> ...</span><br></pre></td></tr></table></figure>

<p>同行多语句不建议使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>:</span><br><span class="line">        do_blah_thing()</span><br><span class="line">    do_one()</span><br><span class="line">    do_two()</span><br><span class="line">    do_three()</span><br><span class="line"></span><br><span class="line">Rather <span class="keyword">not</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: do_blah_thing()</span><br><span class="line">    do_one(); do_two(); do_three()</span><br></pre></td></tr></table></figure>

<p>下面这种丑就不多说了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Rather <span class="keyword">not</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: do_blah_thing()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> lst: total += x</span><br><span class="line">    <span class="keyword">while</span> t &lt; <span class="number">10</span>: t = delay()</span><br><span class="line"></span><br><span class="line">Definitely <span class="keyword">not</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: do_blah_thing()</span><br><span class="line">    <span class="keyword">else</span>: do_non_blah_thing()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>: something()</span><br><span class="line">    <span class="keyword">finally</span>: cleanup()</span><br><span class="line"></span><br><span class="line">    do_one(); do_two(); do_three(long, argument,</span><br><span class="line">                                 <span class="built_in">list</span>, like, this)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> foo == <span class="string">&#x27;blah&#x27;</span>: one(); two(); three()</span><br></pre></td></tr></table></figure>

<h2 id="6">何时使用逗号结尾</h2>
单元素元组强制使用逗号：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    FILES = (<span class="string">&#x27;setup.cfg&#x27;</span>,)</span><br><span class="line"></span><br><span class="line">OK, but confusing:</span><br><span class="line"></span><br><span class="line">    FILES = <span class="string">&#x27;setup.cfg&#x27;</span>,</span><br></pre></td></tr></table></figure>
<p>当使用版本控制系统时，一组希望后续扩展的值/参数/改善的条目使用以下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    FILES = [</span><br><span class="line">        <span class="string">&#x27;setup.cfg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;tox.ini&#x27;</span>,</span><br><span class="line">        ]</span><br><span class="line">    initialize(FILES,</span><br><span class="line">               error=<span class="literal">True</span>,</span><br><span class="line">               )</span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    FILES = [<span class="string">&#x27;setup.cfg&#x27;</span>, <span class="string">&#x27;tox.ini&#x27;</span>,]</span><br><span class="line">    initialize(FILES, error=<span class="literal">True</span>,)</span><br></pre></td></tr></table></figure>


<h2 id="7">注释</h2>

<p>糟糕的注释不如没有注释，一定要用 English 注释。</p>
<h3 id="7.1">块注释</h3>

<p>同等级别的一块代码的注释，块注释内每行注释以 # 开头，内部注释段落之间使用以 # 开头的空行注释隔开。</p>
<h3 id="7.2">行注释</h3>

<p>行注释和代码声明间至少间隔两个空格，不要使用无聊的行注释，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Don<span class="string">&#x27;t do this:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">x = x + 1                 # Increment x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">But sometimes, this is useful:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">x = x + 1                 # Compensate for border</span></span><br></pre></td></tr></table></figure>


<h3 id="7.3">文档字符串</h3>

<p>为所有公共模块，函数，类和方法编写文档字符串。 对于非公共方法，文本字符串不是必需的，但应该有一个描述该方法的注释。例如：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Return a foobang</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Optional plotz says to frobnicate the bizbaz first.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;only one single docstring line&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
注意当注释为多行时，最终的 """ 单独起一行。
</blockquote>

<h2 id="8">命名约定</h2>

<h3 id="8.1">圣经戒律</h3>


<p>对用户可见的公共 API 部分的命名应该遵从反应如何使用而不是怎么实现。</p>
<h3 id="8.2">描述性: 命名风格</h3>

<p>以下命名风格通常区分彼此使用：</p>
<ul>
<li><p>b (单个小写字母)</p>
</li>
<li><p>B (单个大写字母)</p>
</li>
<li><p>lowercase（小写）</p>
</li>
<li><p>lower_case_with_underscores（带下划线的小写）</p>
</li>
<li><p>UPPERCASE（大写）</p>
</li>
<li><p>UPPER_CASE_WITH_UNDERSCORES（带下划线的大写）</p>
</li>
<li><p>CapitalizedWords（驼峰式，蒙古包式 whatever.）</p>
<blockquote>Note: 使用驼峰式时，缩写全部大写，例如：HTTPServerError 好于 HttpServerError </blockquote></li>
<li><p>mixedCase (乌鬼头)</p>
</li>
<li><p>Capitalized_Words_With_Underscores (丑！不解释！)</p>
</li>
<li><p>_single_leading_underscore : 弱地 “内部使用” 指示器. 例如，from M import * 不会导入下划线开头的对象</p>
</li>
<li><p>single_trailing_underscore_ : 用来避免和 python 关键字冲突，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Tkinter.Toplevel(master, class_=<span class="string">&#x27;ClassName&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>__double_leading_underscore : 当对类属性命名时，调用名改变 (在 FooBar 类内，__boo 变成了 _FooBar__boo；后面有介绍)</p>
</li>
<li><p>__double_leading_and_trailing_underscore__ : “魔幻的” 对象或属性，只生存于用户控制的命名空间。例如， __init__ ，__import__ 或 __file__ 。千万不要臆造这种命名； only use them as documented.</p>
</li>
</ul>
<h3 id="8.3">规定性: 命名习惯</h3>

<h4 id="8.3.1">避免的命名</h4>

<p>一定不要使用 l(唉欧儿) O(偶) I(艾) 作为单字符变量命名，在某些字体中，这些字母和数字 1 0 无法区分。</p>
<h4 id="8.3.2">包和模块名</h4>

<p>模块应该使用简短并且全小写的命名，下划线也可以使用以提升可读性。</p>
<p>Python 包也应该使用简短的全小写名称，尽管不鼓励使用下划线。</p>
<p>当 C/C++ 编写的扩展模块伴随一个提供更高级别接口的 python 模块时，C/C++ 模块命名应该以下划线开头(例如，_socket)。</p>
<h4 id="8.3.3">类名</h4>

<p>类名通常使用驼峰式命名习惯。</p>
<p>在类的接口有文档说明，并且主要用于 callable 的情况下，类都是 callable 的，call 一个类将返回一个新的类实例，例如 instance = Class()。如果类实现了 __call__() 函数，那么类实例也将是 callable 的，类的命名也可以使用函数命名习惯。</p>
<p>对于 builtin 函数的命名习惯，可以通过 <code>dir(__builtins__)</code> 查看系统函数命名样例。注意区分普通命名，异常名命名和 builtin 常量。</p>
<h4 id="8.3.4">类型变量名</h4>

<p>相对于短名称如：T，AnyStr，Num，类型变量使用驼峰式命名习惯较好。另外建议在变量名前添加 _co 或 _contra 前缀响应的声明 covariant 或 contravariant 行为。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">VT_co = TypeVar(<span class="string">&#x27;VT_co&#x27;</span>, covariant=<span class="literal">True</span>)</span><br><span class="line">KT_contra = TypeVar(<span class="string">&#x27;KT_contra&#x27;</span>, contravariant=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="8.3.5">异常名</h4>

<p>异常应该是类，所以可以使用类命名习惯，但是，如果异常是个错误类，一般加上 “Error” 后缀。</p>
<h4 id="8.3.6">全局变量名</h4>

<p>我们假设这些全局变量只在一个模块内使用，这样的话和函数的命名习惯是一样的。</p>
<p>设计为通过 <code>from M import *</code> 导入的类应该使用 __all__ 机制避免导出全局变量，或者可以使用老式的习惯，给这些全局变量名加上下划线作为前缀(表示这是非公有变量)。</p>
<h4 id="8.3.7">函数名</h4>

<p>例如，<code>func</code> or <code>func_write_to_file</code></p>
<p>为了向后兼容性，也可以使用 mixedCase 式命名风格。</p>
<h4 id="8.3.8">函数和方法参数</h4>

<p>实例方法第一个入参一定要是 self。<br>类方法第一个入参一定要是 cls。<br>如果函数入参名和保留关键字冲突，则后缀下划线好过缩写或者糟糕的拼写。</p>
<p>例如，class_ 好过 clss。</p>
<h4 id="8.3.9">方法名和实例变量</h4>

<p>使用函数命名风格即可。如果希望是私有方法或实例变量，则前缀下划线。</p>
<p>为避免和子类的命名冲突，请使用双下划线前缀命名。</p>
<p>如果类 Foo 有一个属性变量 __a，那么通过 Foo.__a 是不能被访问的。当然，固执的用户仍然可以通过 Foo._Foo__a 访问），一般来说，双下划线前缀只是在避免子类属性命名冲突的场景下使用。</p>
<h4 id="8.3.10">常量</h4>

<p>常量一般定义在模块级别。命名风格如：MAX_OVERFLOW 或 TOTAL 。</p>
<h4 id="8.3.11">继承设计</h4>

<p>经常去思考类方法和实例变量（属性）应该是公有的还是非公有的（严格意义上，python 没有私有变量）。如果不确定，那就设置成非公有的。</p>
<p>另一类属性类别是子类 API 的一部分，（在其他语言中称”protected”）。有些类天生就是被设计为用来继承的，当设计这种类时，注意哪些属性是公有的，哪些是子类 API 的一部分，哪些是只在基类中使用的。</p>
<p>神谕的指导：</p>
<ul>
<li>公有实例变量不应该有前缀下划线。</li>
<li>公有实例变量和保留关键字冲突时，变量名加前缀下划线避免，这比使用缩写和其他糟糕的拼写要好（除了 ‘cls’，当一个变量或入参确定是一个类，特别是作为类方法的第一个入参时，’cls’ 更惹人喜爱）。</li>
<li>对于简单的公有数据属性，不要使用复杂的存取函数，直接暴露属性名。</li>
<li>如果设计继承基类时，不希望子类访问的属性加双下划线前缀。</li>
</ul>
<h4 id="8.3.12">公共和内部接口</h4>

<p>文档说明的接口一般认为是公共接口，除非文档明确声明为临时或内部接口（为了兼容性等其他原因），所有非文档说明的接口一般为内部接口。</p>
<p>模块应该使用 __all__ 属性明确声明公共 API 名，如果 __all__ 为空，则表明模块没有公共 API。</p>
<p>尽管使用了 __all__ 属性，内部接口（packages, modules, classes, functions, attributes or other names）仍然需要使用前缀下划线。</p>
<p>如果包含的任何一个命名空间（package, module or class）是内部的，那么这个接口也被认为是内部接口。</p>
<p>导入名应该总是被视为实现细节。其他导入模块一定不能依赖对此导入名的间接访问，除非它们是包含模块 API 的显式文档说明的部分，例如 os.path 或者一个 package 向子模块暴露函数的 __init__ 模块。</p>
<h3 id="9">编码建议</h3>

<ul>
<li><p>代码不应该以一种不利于其他 python 实现（PyPy, Jython, IronPython, Cython, Psyco 诸如此类）的方式编写。 例如：不要使用 a += b 或 a = a + b 来实现就地字符串连接，在库的性能敏感部分，应该使用 ‘’.join() 的形式，这就能保证在不同的 python 实现中，连接动作可以在线性时间内完成。</p>
</li>
<li><p>和例如 None 这类 singleton 的比较，应该使用 is 或 is not 而不是 ==。另外，小心使用 <code>if x</code> 如果你的本意是 <code>if x is not None</code>，如果 x 是个布尔变量值 false，那可就完蛋了。</p>
</li>
<li><p>尽管功能相同，从可读性上考虑：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> foo <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> foo <span class="keyword">is</span> <span class="literal">None</span>:</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当使用 rich comparisons 实现排序操作时，最好是实现所有六种操作(__eq__,__ne__, __lt__, __le__, __gt__, __ge__)而不要依赖其他的代码去单独实现某一类比较。为了减少劳动，functools.total_ordering() decorator 提供了一个生成缺失比较方法的工具。</p>
</li>
<li><p>使用 def 语句而不要使用赋值语句去直接绑定一个 lambda 表达式到标识符上：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span> <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    f = <span class="keyword">lambda</span> x: <span class="number">2</span>*x</span><br></pre></td></tr></table></figure>

<p>赋值语句的使用消除了 lambda 表达式相对于显式 def 语句的唯一好处，那就是它能够嵌入到一个更大的表达式里面。</p>
<ul>
<li><p>捕获的异常要说明 “错误出在哪里了 ？” 而不是仅仅说明 “哎呀！出问题了！”。</p>
</li>
<li><p>正确使用异常链接。在 Python 3 中，应该使用 “raise X from Y” 来表示显式替换并且不会丢失原始追溯。</p>
</li>
</ul>
<p>当有意替换一个内部异常(Python 2: “raise X”, Python 3.3+: raise X from Non)时，请确保将相关的详细信息转移到新的异常(例如，将 KeyError 转换为 AttributeError 时保留属性名称，或将原始异常的文本嵌入到新的异常消息中)。</p>
<ul>
<li><p>当在 Python 2 中抛出异常时，使用 <code>raise ValueError('message')</code> 而不是老式的 <code>raise ValueError, 'message'</code>，后者已经在 Python 3 中废弃。由于使用了括号，可以避免行连续符的使用。</p>
</li>
<li><p>当捕获异常时，尽可能提及具体的异常而不是使用一个赤裸裸的 except 子句。一个裸露的 except: 子句将捕获 SystemExit 和 KeyboardInterrupt 异常，这样的话就难于使用 control-c 中断程序，并可能掩盖其他问题。如果想要捕获标志程序错误的所有异常的话，用 except Exception:(裸露的 except 子句等同于 except BaseException:)：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> platform_specific_module</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    platform_specific_module = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<blockquote>

<p>一个很好的经验法则是将裸露的 except 子句仅用于以下两种情况：  </p>
<p>1、If the exception handler will be printing out or logging the traceback; at least the user will be aware that an error has occurred.</p>
<p>2、If the code needs to do some cleanup work, but then lets the exception propagate upwards with raise . try…finally can be a better way to handle this case.</p>
</blockquote>

<ul>
<li>当对捕获的异常重命名时，使用 2.6 版本引入的语法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    process_data()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">    <span class="keyword">raise</span> DataProcessingFailedError(<span class="built_in">str</span>(exc))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当捕获操作系统错误时，相对于内置的 errno 值，最好是使用 Python 3.3 中介绍的显式异常层次结构。</p>
</li>
<li><p>对于所有的 try/except 子句，将 try 子句限制为必需的绝对最小代码量避免隐藏 bug：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        value = collection[key]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">return</span> key_not_found(key)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> handle_value(value)</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Too broad!</span></span><br><span class="line">        <span class="keyword">return</span> handle_value(collection[key])</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="comment"># Will also catch KeyError raised by handle_value()</span></span><br><span class="line">        <span class="keyword">return</span> key_not_found(key)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>特定代码块的本地资源使用 with 语句确保使用后立即释放，不能自动释放的使用 try/finally 也可以。</p>
</li>
<li><p>除了申请和释放资源，任何时候都应该使用单独的函数和方法调用 Context managers，例如：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> conn.begin_transaction():</span><br><span class="line">        do_stuff_in_transaction(conn)</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">        do_stuff_in_transaction(conn) </span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数返回语句要一致。在一个函数内的所有返回语句要么都返回一个表达式，要么都不返回。如果任何一个返回语句返回了表达式，那么其他任何没有返回值的语句应该明确声明为 return None。在函数结束部分必须出现返回语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> math.sqrt(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(x)</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> math.sqrt(x)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(x)</span><br></pre></td></tr></table></figure></li>
<li><p>相对于 string 模块，使用 string 方法要快的多并且与 unicode strings 共享相同的 API。当然了，除了需要考虑 2.0 版本之前 python 代码向后兼容性的情况。</p>
</li>
<li><p>使用 ‘’.startswith() 和 ‘’.endswith() 而不是字符串切片来检查前缀或后缀，例如：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是： <span class="keyword">if</span> foo.startswith(<span class="string">&#x27;bar&#x27;</span>):</span><br><span class="line">否： <span class="keyword">if</span> foo[:<span class="number">3</span>] == <span class="string">&#x27;bar&#x27;</span>:</span><br></pre></td></tr></table></figure>

<ul>
<li>对象类型比较应该使用isinstance() 而不是直接比较：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是： <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">int</span>):</span><br><span class="line">否： <span class="keyword">if</span> <span class="built_in">type</span>(obj) <span class="keyword">is</span> <span class="built_in">type</span>(<span class="number">1</span>):</span><br></pre></td></tr></table></figure>

<p>当检查一个对象是否为字符串时，一定要注意这个对象也可能是 unicode 字符串！在 Python 2 中，string 和 unicode 拥有一个公共基类 basestring，因此可以这么的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, basestring):</span><br></pre></td></tr></table></figure>

<p>在 Python 3 中，unicode 和 basestring 已然不复存在(there’s only str)，并且 bytes object 也不再视为一种 string 了，而是一个整形序列。</p>
<ul>
<li><p>对于序列（字符串，列表，元组）的判空操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> seq:</span><br><span class="line">    <span class="keyword">if</span> seq:</span><br><span class="line"></span><br><span class="line">否：</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(seq):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(seq):</span><br></pre></td></tr></table></figure></li>
<li><p>不要使用尾随空格。</p>
</li>
<li><p>不要使用 == 验证布尔值为 Ture 或 False：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">是：</span><br><span class="line">      <span class="keyword">if</span> greeting:</span><br><span class="line">否：</span><br><span class="line">      <span class="keyword">if</span> greeting == <span class="literal">True</span>:</span><br><span class="line">虾扯蛋：</span><br><span class="line">      <span class="keyword">if</span> greeting <span class="keyword">is</span> <span class="literal">True</span>:</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">WinkyQin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://winkyqin.com/2019/09/21/00-Python/2022-09-23-Python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">http://winkyqin.com/2019/09/21/00-Python/2022-09-23-Python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://winkyqin.com" target="_blank">Qin Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">Python 编码规范</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/27/Books/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/001_%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第1章 开发环境配置</div></div></a></div><div class="next-post pull-right"><a href="/2019/09/21/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/2022-09-28-%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《技术管理之巅》读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">WinkyQin</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">199</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/winkyqin"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/winkyqin" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.zhihu.com/people/winkyqin" target="_blank" title="Zhihu"><i class="fab fa-zhihu"></i></a><a class="social-icon" href="https://www.linkedin.com/in/winkyqin/" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="mailto:winkyqin@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">Have a nice day!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.</span> <span class="toc-text">Python编码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#google-python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83"><span class="toc-number">1.1.</span> <span class="toc-text">google python编码规范参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PEP-8-Python-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97"><span class="toc-number">1.2.</span> <span class="toc-text">PEP 8 - Python 代码风格指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1"><span class="toc-number">1.3.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3"><span class="toc-number">1.4.</span> <span class="toc-text">代码布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3.1"><span class="toc-number">1.4.1.</span> <span class="toc-text">缩进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.2"><span class="toc-number">1.4.2.</span> <span class="toc-text">A 罩杯还是 E 罩杯 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.3"><span class="toc-number">1.4.3.</span> <span class="toc-text">代码行最大长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.4"><span class="toc-number">1.4.4.</span> <span class="toc-text">在二元运算符之前还是之后断行?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.8"><span class="toc-number">1.4.5.</span> <span class="toc-text">模块级别 dunder 名称</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4"><span class="toc-number">1.5.</span> <span class="toc-text">字符串引号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5"><span class="toc-number">1.6.</span> <span class="toc-text">表达式和语句中的空格

心理藏的小烦恼

在以下场景避免不必要的空格
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
是： spam(ham[1], &amp;#123;eggs: 2&amp;#125;)
否： spam( ham[ 1 ], &amp;#123; eggs: 2 &amp;#125; )

是： foo &#x3D; (0,)
否： bar &#x3D; (0, )

是： if x &#x3D;&#x3D; 4: print x, y; x, y &#x3D; y, x
否： if x &#x3D;&#x3D; 4 : print x , y ; x , y &#x3D; y , x

是：
    ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
    ham[lower:upper], ham[lower:upper:], ham[lower::step]
    ham[lower+offset : upper+offset]
    ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
    ham[lower + offset : upper + offset]

否：
    ham[lower + offset:upper + offset]
    ham[1: 9], ham[1 :9], ham[1:9 :3]
    ham[lower : : upper]
    ham[ : upper]
    
是： spam(1)
否： spam (1)

是： dct[&amp;#x27;key&amp;#x27;] &#x3D; lst[index]
否： dct [&amp;#x27;key&amp;#x27;] &#x3D; lst [index]

是：
    x &#x3D; 1
    y &#x3D; 2
    long_variable &#x3D; 3
    
否：
    x             &#x3D; 1
    y             &#x3D; 2
    long_variable &#x3D; 3
    


其他建议

在任何地方避免使用尾随空格。
在二元运算符周围使用空格：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
是：

    i &#x3D; i + 1
    submitted +&#x3D; 1
    x &#x3D; x*2 - 1
    hypot2 &#x3D; x*x + y*y
    c &#x3D; (a+b) * (a-b)
    
否：

    i&#x3D;i+1
    submitted +&#x3D;1
    x &#x3D; x * 2 - 1
    hypot2 &#x3D; x * x + y * y
    c &#x3D; (a + b) * (a - b)

表示关键字参数或默认参数值时，不要使用空格：
1
2
3
4
5
6
7
8
是：

    def complex(real, imag&#x3D;0.0):
        return magic(r&#x3D;real, i&#x3D;imag)
否：

    def complex(real, imag &#x3D; 0.0):
        return magic(r &#x3D; real, i &#x3D; imag)

函数注解的场景：
1
2
3
4
5
6
7
8
9
是：

    def munge(input: AnyStr): ...
    def munge() -&gt; AnyStr: ...

否：

    def munge(input:AnyStr): ...
    def munge()-&gt;PosInt: ...


当参数注释和默认值共存时：
1
2
3
4
5
6
7
8
9
是：

    def munge(sep: AnyStr &#x3D; None): ...
    def munge(input: AnyStr, sep: AnyStr &#x3D; None, limit&#x3D;1000): ...

否：

    def munge(input: AnyStr&#x3D;None): ...
    def munge(input: AnyStr, limit &#x3D; 1000): ...


同行多语句不建议使用：
1
2
3
4
5
6
7
8
9
10
11
12
是：

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;:
        do_blah_thing()
    do_one()
    do_two()
    do_three()

Rather not:

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;: do_blah_thing()
    do_one(); do_two(); do_three()


下面这种丑就不多说了：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
Rather not:

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;: do_blah_thing()
    for x in lst: total +&#x3D; x
    while t &lt; 10: t &#x3D; delay()

Definitely not:

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;: do_blah_thing()
    else: do_non_blah_thing()

    try: something()
    finally: cleanup()

    do_one(); do_two(); do_three(long, argument,
                                 list, like, this)

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;: one(); two(); three()


何时使用逗号结尾
单元素元组强制使用逗号：

1
2
3
4
5
6
7
是：

    FILES &#x3D; (&amp;#x27;setup.cfg&amp;#x27;,)

OK, but confusing:

    FILES &#x3D; &amp;#x27;setup.cfg&amp;#x27;,

当使用版本控制系统时，一组希望后续扩展的值&#x2F;参数&#x2F;改善的条目使用以下形式：
1
2
3
4
5
6
7
8
9
10
11
12
13
是：

    FILES &#x3D; [
        &amp;#x27;setup.cfg&amp;#x27;,
        &amp;#x27;tox.ini&amp;#x27;,
        ]
    initialize(FILES,
               error&#x3D;True,
               )
否：

    FILES &#x3D; [&amp;#x27;setup.cfg&amp;#x27;, &amp;#x27;tox.ini&amp;#x27;,]
    initialize(FILES, error&#x3D;True,)



注释

糟糕的注释不如没有注释，一定要用 English 注释。
块注释

同等级别的一块代码的注释，块注释内每行注释以 # 开头，内部注释段落之间使用以 # 开头的空行注释隔开。
行注释

行注释和代码声明间至少间隔两个空格，不要使用无聊的行注释，例如：
1
2
3
4
5
6
7
Don&amp;#x27;t do this:

x &#x3D; x + 1                 # Increment x

But sometimes, this is useful:

x &#x3D; x + 1                 # Compensate for border



文档字符串

为所有公共模块，函数，类和方法编写文档字符串。 对于非公共方法，文本字符串不是必需的，但应该有一个描述该方法的注释。例如：  
1
2
3
4
5
6
&quot;&quot;&quot;Return a foobang

Optional plotz says to frobnicate the bizbaz first.
&quot;&quot;&quot;

&quot;&quot;&quot;only one single docstring line&quot;&quot;&quot;


注意当注释为多行时，最终的 &quot;&quot;&quot; 单独起一行。


命名约定

圣经戒律


对用户可见的公共 API 部分的命名应该遵从反应如何使用而不是怎么实现。
描述性: 命名风格

以下命名风格通常区分彼此使用：

b (单个小写字母)

B (单个大写字母)

lowercase（小写）

lower_case_with_underscores（带下划线的小写）

UPPERCASE（大写）

UPPER_CASE_WITH_UNDERSCORES（带下划线的大写）

CapitalizedWords（驼峰式，蒙古包式 whatever.）
Note: 使用驼峰式时，缩写全部大写，例如：HTTPServerError 好于 HttpServerError 
mixedCase (乌鬼头)

Capitalized_Words_With_Underscores (丑！不解释！)

_single_leading_underscore : 弱地 “内部使用” 指示器. 例如，from M import * 不会导入下划线开头的对象

single_trailing_underscore_ : 用来避免和 python 关键字冲突，例如：
1
2

Tkinter.Toplevel(master, class_&#x3D;&amp;#x27;ClassName&amp;#x27;)

__double_leading_underscore : 当对类属性命名时，调用名改变 (在 FooBar 类内，__boo 变成了 _FooBar__boo；后面有介绍)

__double_leading_and_trailing_underscore__ : “魔幻的” 对象或属性，只生存于用户控制的命名空间。例如， __init__ ，__import__ 或 __file__ 。千万不要臆造这种命名； only use them as documented.


规定性: 命名习惯

避免的命名

一定不要使用 l(唉欧儿) O(偶) I(艾) 作为单字符变量命名，在某些字体中，这些字母和数字 1 0 无法区分。
包和模块名

模块应该使用简短并且全小写的命名，下划线也可以使用以提升可读性。
Python 包也应该使用简短的全小写名称，尽管不鼓励使用下划线。
当 C&#x2F;C++ 编写的扩展模块伴随一个提供更高级别接口的 python 模块时，C&#x2F;C++ 模块命名应该以下划线开头(例如，_socket)。
类名

类名通常使用驼峰式命名习惯。
在类的接口有文档说明，并且主要用于 callable 的情况下，类都是 callable 的，call 一个类将返回一个新的类实例，例如 instance &#x3D; Class()。如果类实现了 __call__() 函数，那么类实例也将是 callable 的，类的命名也可以使用函数命名习惯。
对于 builtin 函数的命名习惯，可以通过 dir(__builtins__) 查看系统函数命名样例。注意区分普通命名，异常名命名和 builtin 常量。
类型变量名

相对于短名称如：T，AnyStr，Num，类型变量使用驼峰式命名习惯较好。另外建议在变量名前添加 _co 或 _contra 前缀响应的声明 covariant 或 contravariant 行为。例如：
1
2
3
4
from typing import TypeVar

VT_co &#x3D; TypeVar(&amp;#x27;VT_co&amp;#x27;, covariant&#x3D;True)
KT_contra &#x3D; TypeVar(&amp;#x27;KT_contra&amp;#x27;, contravariant&#x3D;True)


异常名

异常应该是类，所以可以使用类命名习惯，但是，如果异常是个错误类，一般加上 “Error” 后缀。
全局变量名

我们假设这些全局变量只在一个模块内使用，这样的话和函数的命名习惯是一样的。
设计为通过 from M import * 导入的类应该使用 __all__ 机制避免导出全局变量，或者可以使用老式的习惯，给这些全局变量名加上下划线作为前缀(表示这是非公有变量)。
函数名

例如，func or func_write_to_file
为了向后兼容性，也可以使用 mixedCase 式命名风格。
函数和方法参数

实例方法第一个入参一定要是 self。
类方法第一个入参一定要是 cls。
如果函数入参名和保留关键字冲突，则后缀下划线好过缩写或者糟糕的拼写。
例如，class_ 好过 clss。
方法名和实例变量

使用函数命名风格即可。如果希望是私有方法或实例变量，则前缀下划线。
为避免和子类的命名冲突，请使用双下划线前缀命名。
如果类 Foo 有一个属性变量 __a，那么通过 Foo.__a 是不能被访问的。当然，固执的用户仍然可以通过 Foo._Foo__a 访问），一般来说，双下划线前缀只是在避免子类属性命名冲突的场景下使用。
常量

常量一般定义在模块级别。命名风格如：MAX_OVERFLOW 或 TOTAL 。
继承设计

经常去思考类方法和实例变量（属性）应该是公有的还是非公有的（严格意义上，python 没有私有变量）。如果不确定，那就设置成非公有的。
另一类属性类别是子类 API 的一部分，（在其他语言中称”protected”）。有些类天生就是被设计为用来继承的，当设计这种类时，注意哪些属性是公有的，哪些是子类 API 的一部分，哪些是只在基类中使用的。
神谕的指导：

公有实例变量不应该有前缀下划线。
公有实例变量和保留关键字冲突时，变量名加前缀下划线避免，这比使用缩写和其他糟糕的拼写要好（除了 ‘cls’，当一个变量或入参确定是一个类，特别是作为类方法的第一个入参时，’cls’ 更惹人喜爱）。
对于简单的公有数据属性，不要使用复杂的存取函数，直接暴露属性名。
如果设计继承基类时，不希望子类访问的属性加双下划线前缀。

公共和内部接口

文档说明的接口一般认为是公共接口，除非文档明确声明为临时或内部接口（为了兼容性等其他原因），所有非文档说明的接口一般为内部接口。
模块应该使用 __all__ 属性明确声明公共 API 名，如果 __all__ 为空，则表明模块没有公共 API。
尽管使用了 __all__ 属性，内部接口（packages, modules, classes, functions, attributes or other names）仍然需要使用前缀下划线。
如果包含的任何一个命名空间（package, module or class）是内部的，那么这个接口也被认为是内部接口。
导入名应该总是被视为实现细节。其他导入模块一定不能依赖对此导入名的间接访问，除非它们是包含模块 API 的显式文档说明的部分，例如 os.path 或者一个 package 向子模块暴露函数的 __init__ 模块。
编码建议


代码不应该以一种不利于其他 python 实现（PyPy, Jython, IronPython, Cython, Psyco 诸如此类）的方式编写。 例如：不要使用 a +&#x3D; b 或 a &#x3D; a + b 来实现就地字符串连接，在库的性能敏感部分，应该使用 ‘’.join() 的形式，这就能保证在不同的 python 实现中，连接动作可以在线性时间内完成。

和例如 None 这类 singleton 的比较，应该使用 is 或 is not 而不是 &#x3D;&#x3D;。另外，小心使用 if x 如果你的本意是 if x is not None，如果 x 是个布尔变量值 false，那可就完蛋了。

尽管功能相同，从可读性上考虑：


1
2
3
4
5
6
7
是：

    if foo is not None:

否：

    if not foo is None:


当使用 rich comparisons 实现排序操作时，最好是实现所有六种操作(__eq__,__ne__, __lt__, __le__, __gt__, __ge__)而不要依赖其他的代码去单独实现某一类比较。为了减少劳动，functools.total_ordering() decorator 提供了一个生成缺失比较方法的工具。

使用 def 语句而不要使用赋值语句去直接绑定一个 lambda 表达式到标识符上：


1
2
3
4
5
6
7
是：

    def f(x): return 2*x

否：

    f &#x3D; lambda x: 2*x


赋值语句的使用消除了 lambda 表达式相对于显式 def 语句的唯一好处，那就是它能够嵌入到一个更大的表达式里面。

捕获的异常要说明 “错误出在哪里了 ？” 而不是仅仅说明 “哎呀！出问题了！”。

正确使用异常链接。在 Python 3 中，应该使用 “raise X from Y” 来表示显式替换并且不会丢失原始追溯。


当有意替换一个内部异常(Python 2: “raise X”, Python 3.3+: raise X from Non)时，请确保将相关的详细信息转移到新的异常(例如，将 KeyError 转换为 AttributeError 时保留属性名称，或将原始异常的文本嵌入到新的异常消息中)。

当在 Python 2 中抛出异常时，使用 raise ValueError(&#39;message&#39;) 而不是老式的 raise ValueError, &#39;message&#39;，后者已经在 Python 3 中废弃。由于使用了括号，可以避免行连续符的使用。

当捕获异常时，尽可能提及具体的异常而不是使用一个赤裸裸的 except 子句。一个裸露的 except: 子句将捕获 SystemExit 和 KeyboardInterrupt 异常，这样的话就难于使用 control-c 中断程序，并可能掩盖其他问题。如果想要捕获标志程序错误的所有异常的话，用 except Exception:(裸露的 except 子句等同于 except BaseException:)：


1
2
3
4
try:
    import platform_specific_module
except ImportError:
    platform_specific_module &#x3D; None




一个很好的经验法则是将裸露的 except 子句仅用于以下两种情况：  
1、If the exception handler will be printing out or logging the traceback; at least the user will be aware that an error has occurred.
2、If the code needs to do some cleanup work, but then lets the exception propagate upwards with raise . try…finally can be a better way to handle this case.



当对捕获的异常重命名时，使用 2.6 版本引入的语法：

1
2
3
4
try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))



当捕获操作系统错误时，相对于内置的 errno 值，最好是使用 Python 3.3 中介绍的显式异常层次结构。

对于所有的 try&#x2F;except 子句，将 try 子句限制为必需的绝对最小代码量避免隐藏 bug：


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
是：

    try:
        value &#x3D; collection[key]
    except KeyError:
        return key_not_found(key)
    else:
        return handle_value(value)

否：

    try:
        # Too broad!
        return handle_value(collection[key])
    except KeyError:
        # Will also catch KeyError raised by handle_value()
        return key_not_found(key)



特定代码块的本地资源使用 with 语句确保使用后立即释放，不能自动释放的使用 try&#x2F;finally 也可以。

除了申请和释放资源，任何时候都应该使用单独的函数和方法调用 Context managers，例如：


1
2
3
4
5
6
7
8
9
是：

    with conn.begin_transaction():
        do_stuff_in_transaction(conn)

否：

    with conn:
        do_stuff_in_transaction(conn) 



函数返回语句要一致。在一个函数内的所有返回语句要么都返回一个表达式，要么都不返回。如果任何一个返回语句返回了表达式，那么其他任何没有返回值的语句应该明确声明为 return None。在函数结束部分必须出现返回语句：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
是：

    def foo(x):
        if x &gt;&#x3D; 0:
            return math.sqrt(x)
        else:
            return None
    
    def bar(x):
        if x &lt; 0:
            return None
        return math.sqrt(x)

否：

    def foo(x):
        if x &gt;&#x3D; 0:
            return math.sqrt(x)
    
    def bar(x):
        if x &lt; 0:
            return
        return math.sqrt(x)

相对于 string 模块，使用 string 方法要快的多并且与 unicode strings 共享相同的 API。当然了，除了需要考虑 2.0 版本之前 python 代码向后兼容性的情况。

使用 ‘’.startswith() 和 ‘’.endswith() 而不是字符串切片来检查前缀或后缀，例如：


1
2
是： if foo.startswith(&amp;#x27;bar&amp;#x27;):
否： if foo[:3] &#x3D;&#x3D; &amp;#x27;bar&amp;#x27;:



对象类型比较应该使用isinstance() 而不是直接比较：

1
2
是： if isinstance(obj, int):
否： if type(obj) is type(1):


当检查一个对象是否为字符串时，一定要注意这个对象也可能是 unicode 字符串！在 Python 2 中，string 和 unicode 拥有一个公共基类 basestring，因此可以这么的：
1
if isinstance(obj, basestring):


在 Python 3 中，unicode 和 basestring 已然不复存在(there’s only str)，并且 bytes object 也不再视为一种 string 了，而是一个整形序列。

对于序列（字符串，列表，元组）的判空操作：
1
2
3
4
5
6
7
是：
    if not seq:
    if seq:

否：
    if len(seq):
    if not len(seq):

不要使用尾随空格。

不要使用 &#x3D;&#x3D; 验证布尔值为 Ture 或 False：


1
2
3
4
5
6
是：
      if greeting:
否：
      if greeting &#x3D;&#x3D; True:
虾扯蛋：
      if greeting is True:


</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5"><span class="toc-number">1.7.</span> <span class="toc-text">

心理藏的小烦恼

在以下场景避免不必要的空格
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
是： spam(ham[1], &amp;#123;eggs: 2&amp;#125;)
否： spam( ham[ 1 ], &amp;#123; eggs: 2 &amp;#125; )

是： foo &#x3D; (0,)
否： bar &#x3D; (0, )

是： if x &#x3D;&#x3D; 4: print x, y; x, y &#x3D; y, x
否： if x &#x3D;&#x3D; 4 : print x , y ; x , y &#x3D; y , x

是：
    ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
    ham[lower:upper], ham[lower:upper:], ham[lower::step]
    ham[lower+offset : upper+offset]
    ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
    ham[lower + offset : upper + offset]

否：
    ham[lower + offset:upper + offset]
    ham[1: 9], ham[1 :9], ham[1:9 :3]
    ham[lower : : upper]
    ham[ : upper]
    
是： spam(1)
否： spam (1)

是： dct[&amp;#x27;key&amp;#x27;] &#x3D; lst[index]
否： dct [&amp;#x27;key&amp;#x27;] &#x3D; lst [index]

是：
    x &#x3D; 1
    y &#x3D; 2
    long_variable &#x3D; 3
    
否：
    x             &#x3D; 1
    y             &#x3D; 2
    long_variable &#x3D; 3
    


其他建议

在任何地方避免使用尾随空格。
在二元运算符周围使用空格：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
是：

    i &#x3D; i + 1
    submitted +&#x3D; 1
    x &#x3D; x*2 - 1
    hypot2 &#x3D; x*x + y*y
    c &#x3D; (a+b) * (a-b)
    
否：

    i&#x3D;i+1
    submitted +&#x3D;1
    x &#x3D; x * 2 - 1
    hypot2 &#x3D; x * x + y * y
    c &#x3D; (a + b) * (a - b)

表示关键字参数或默认参数值时，不要使用空格：
1
2
3
4
5
6
7
8
是：

    def complex(real, imag&#x3D;0.0):
        return magic(r&#x3D;real, i&#x3D;imag)
否：

    def complex(real, imag &#x3D; 0.0):
        return magic(r &#x3D; real, i &#x3D; imag)

函数注解的场景：
1
2
3
4
5
6
7
8
9
是：

    def munge(input: AnyStr): ...
    def munge() -&gt; AnyStr: ...

否：

    def munge(input:AnyStr): ...
    def munge()-&gt;PosInt: ...


当参数注释和默认值共存时：
1
2
3
4
5
6
7
8
9
是：

    def munge(sep: AnyStr &#x3D; None): ...
    def munge(input: AnyStr, sep: AnyStr &#x3D; None, limit&#x3D;1000): ...

否：

    def munge(input: AnyStr&#x3D;None): ...
    def munge(input: AnyStr, limit &#x3D; 1000): ...


同行多语句不建议使用：
1
2
3
4
5
6
7
8
9
10
11
12
是：

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;:
        do_blah_thing()
    do_one()
    do_two()
    do_three()

Rather not:

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;: do_blah_thing()
    do_one(); do_two(); do_three()


下面这种丑就不多说了：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
Rather not:

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;: do_blah_thing()
    for x in lst: total +&#x3D; x
    while t &lt; 10: t &#x3D; delay()

Definitely not:

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;: do_blah_thing()
    else: do_non_blah_thing()

    try: something()
    finally: cleanup()

    do_one(); do_two(); do_three(long, argument,
                                 list, like, this)

    if foo &#x3D;&#x3D; &amp;#x27;blah&amp;#x27;: one(); two(); three()


何时使用逗号结尾
单元素元组强制使用逗号：

1
2
3
4
5
6
7
是：

    FILES &#x3D; (&amp;#x27;setup.cfg&amp;#x27;,)

OK, but confusing:

    FILES &#x3D; &amp;#x27;setup.cfg&amp;#x27;,

当使用版本控制系统时，一组希望后续扩展的值&#x2F;参数&#x2F;改善的条目使用以下形式：
1
2
3
4
5
6
7
8
9
10
11
12
13
是：

    FILES &#x3D; [
        &amp;#x27;setup.cfg&amp;#x27;,
        &amp;#x27;tox.ini&amp;#x27;,
        ]
    initialize(FILES,
               error&#x3D;True,
               )
否：

    FILES &#x3D; [&amp;#x27;setup.cfg&amp;#x27;, &amp;#x27;tox.ini&amp;#x27;,]
    initialize(FILES, error&#x3D;True,)



注释

糟糕的注释不如没有注释，一定要用 English 注释。
块注释

同等级别的一块代码的注释，块注释内每行注释以 # 开头，内部注释段落之间使用以 # 开头的空行注释隔开。
行注释

行注释和代码声明间至少间隔两个空格，不要使用无聊的行注释，例如：
1
2
3
4
5
6
7
Don&amp;#x27;t do this:

x &#x3D; x + 1                 # Increment x

But sometimes, this is useful:

x &#x3D; x + 1                 # Compensate for border



文档字符串

为所有公共模块，函数，类和方法编写文档字符串。 对于非公共方法，文本字符串不是必需的，但应该有一个描述该方法的注释。例如：  
1
2
3
4
5
6
&quot;&quot;&quot;Return a foobang

Optional plotz says to frobnicate the bizbaz first.
&quot;&quot;&quot;

&quot;&quot;&quot;only one single docstring line&quot;&quot;&quot;


注意当注释为多行时，最终的 &quot;&quot;&quot; 单独起一行。


命名约定

圣经戒律


对用户可见的公共 API 部分的命名应该遵从反应如何使用而不是怎么实现。
描述性: 命名风格

以下命名风格通常区分彼此使用：

b (单个小写字母)

B (单个大写字母)

lowercase（小写）

lower_case_with_underscores（带下划线的小写）

UPPERCASE（大写）

UPPER_CASE_WITH_UNDERSCORES（带下划线的大写）

CapitalizedWords（驼峰式，蒙古包式 whatever.）
Note: 使用驼峰式时，缩写全部大写，例如：HTTPServerError 好于 HttpServerError 
mixedCase (乌鬼头)

Capitalized_Words_With_Underscores (丑！不解释！)

_single_leading_underscore : 弱地 “内部使用” 指示器. 例如，from M import * 不会导入下划线开头的对象

single_trailing_underscore_ : 用来避免和 python 关键字冲突，例如：
1
2

Tkinter.Toplevel(master, class_&#x3D;&amp;#x27;ClassName&amp;#x27;)

__double_leading_underscore : 当对类属性命名时，调用名改变 (在 FooBar 类内，__boo 变成了 _FooBar__boo；后面有介绍)

__double_leading_and_trailing_underscore__ : “魔幻的” 对象或属性，只生存于用户控制的命名空间。例如， __init__ ，__import__ 或 __file__ 。千万不要臆造这种命名； only use them as documented.


规定性: 命名习惯

避免的命名

一定不要使用 l(唉欧儿) O(偶) I(艾) 作为单字符变量命名，在某些字体中，这些字母和数字 1 0 无法区分。
包和模块名

模块应该使用简短并且全小写的命名，下划线也可以使用以提升可读性。
Python 包也应该使用简短的全小写名称，尽管不鼓励使用下划线。
当 C&#x2F;C++ 编写的扩展模块伴随一个提供更高级别接口的 python 模块时，C&#x2F;C++ 模块命名应该以下划线开头(例如，_socket)。
类名

类名通常使用驼峰式命名习惯。
在类的接口有文档说明，并且主要用于 callable 的情况下，类都是 callable 的，call 一个类将返回一个新的类实例，例如 instance &#x3D; Class()。如果类实现了 __call__() 函数，那么类实例也将是 callable 的，类的命名也可以使用函数命名习惯。
对于 builtin 函数的命名习惯，可以通过 dir(__builtins__) 查看系统函数命名样例。注意区分普通命名，异常名命名和 builtin 常量。
类型变量名

相对于短名称如：T，AnyStr，Num，类型变量使用驼峰式命名习惯较好。另外建议在变量名前添加 _co 或 _contra 前缀响应的声明 covariant 或 contravariant 行为。例如：
1
2
3
4
from typing import TypeVar

VT_co &#x3D; TypeVar(&amp;#x27;VT_co&amp;#x27;, covariant&#x3D;True)
KT_contra &#x3D; TypeVar(&amp;#x27;KT_contra&amp;#x27;, contravariant&#x3D;True)


异常名

异常应该是类，所以可以使用类命名习惯，但是，如果异常是个错误类，一般加上 “Error” 后缀。
全局变量名

我们假设这些全局变量只在一个模块内使用，这样的话和函数的命名习惯是一样的。
设计为通过 from M import * 导入的类应该使用 __all__ 机制避免导出全局变量，或者可以使用老式的习惯，给这些全局变量名加上下划线作为前缀(表示这是非公有变量)。
函数名

例如，func or func_write_to_file
为了向后兼容性，也可以使用 mixedCase 式命名风格。
函数和方法参数

实例方法第一个入参一定要是 self。
类方法第一个入参一定要是 cls。
如果函数入参名和保留关键字冲突，则后缀下划线好过缩写或者糟糕的拼写。
例如，class_ 好过 clss。
方法名和实例变量

使用函数命名风格即可。如果希望是私有方法或实例变量，则前缀下划线。
为避免和子类的命名冲突，请使用双下划线前缀命名。
如果类 Foo 有一个属性变量 __a，那么通过 Foo.__a 是不能被访问的。当然，固执的用户仍然可以通过 Foo._Foo__a 访问），一般来说，双下划线前缀只是在避免子类属性命名冲突的场景下使用。
常量

常量一般定义在模块级别。命名风格如：MAX_OVERFLOW 或 TOTAL 。
继承设计

经常去思考类方法和实例变量（属性）应该是公有的还是非公有的（严格意义上，python 没有私有变量）。如果不确定，那就设置成非公有的。
另一类属性类别是子类 API 的一部分，（在其他语言中称”protected”）。有些类天生就是被设计为用来继承的，当设计这种类时，注意哪些属性是公有的，哪些是子类 API 的一部分，哪些是只在基类中使用的。
神谕的指导：

公有实例变量不应该有前缀下划线。
公有实例变量和保留关键字冲突时，变量名加前缀下划线避免，这比使用缩写和其他糟糕的拼写要好（除了 ‘cls’，当一个变量或入参确定是一个类，特别是作为类方法的第一个入参时，’cls’ 更惹人喜爱）。
对于简单的公有数据属性，不要使用复杂的存取函数，直接暴露属性名。
如果设计继承基类时，不希望子类访问的属性加双下划线前缀。

公共和内部接口

文档说明的接口一般认为是公共接口，除非文档明确声明为临时或内部接口（为了兼容性等其他原因），所有非文档说明的接口一般为内部接口。
模块应该使用 __all__ 属性明确声明公共 API 名，如果 __all__ 为空，则表明模块没有公共 API。
尽管使用了 __all__ 属性，内部接口（packages, modules, classes, functions, attributes or other names）仍然需要使用前缀下划线。
如果包含的任何一个命名空间（package, module or class）是内部的，那么这个接口也被认为是内部接口。
导入名应该总是被视为实现细节。其他导入模块一定不能依赖对此导入名的间接访问，除非它们是包含模块 API 的显式文档说明的部分，例如 os.path 或者一个 package 向子模块暴露函数的 __init__ 模块。
编码建议


代码不应该以一种不利于其他 python 实现（PyPy, Jython, IronPython, Cython, Psyco 诸如此类）的方式编写。 例如：不要使用 a +&#x3D; b 或 a &#x3D; a + b 来实现就地字符串连接，在库的性能敏感部分，应该使用 ‘’.join() 的形式，这就能保证在不同的 python 实现中，连接动作可以在线性时间内完成。

和例如 None 这类 singleton 的比较，应该使用 is 或 is not 而不是 &#x3D;&#x3D;。另外，小心使用 if x 如果你的本意是 if x is not None，如果 x 是个布尔变量值 false，那可就完蛋了。

尽管功能相同，从可读性上考虑：


1
2
3
4
5
6
7
是：

    if foo is not None:

否：

    if not foo is None:


当使用 rich comparisons 实现排序操作时，最好是实现所有六种操作(__eq__,__ne__, __lt__, __le__, __gt__, __ge__)而不要依赖其他的代码去单独实现某一类比较。为了减少劳动，functools.total_ordering() decorator 提供了一个生成缺失比较方法的工具。

使用 def 语句而不要使用赋值语句去直接绑定一个 lambda 表达式到标识符上：


1
2
3
4
5
6
7
是：

    def f(x): return 2*x

否：

    f &#x3D; lambda x: 2*x


赋值语句的使用消除了 lambda 表达式相对于显式 def 语句的唯一好处，那就是它能够嵌入到一个更大的表达式里面。

捕获的异常要说明 “错误出在哪里了 ？” 而不是仅仅说明 “哎呀！出问题了！”。

正确使用异常链接。在 Python 3 中，应该使用 “raise X from Y” 来表示显式替换并且不会丢失原始追溯。


当有意替换一个内部异常(Python 2: “raise X”, Python 3.3+: raise X from Non)时，请确保将相关的详细信息转移到新的异常(例如，将 KeyError 转换为 AttributeError 时保留属性名称，或将原始异常的文本嵌入到新的异常消息中)。

当在 Python 2 中抛出异常时，使用 raise ValueError(&#39;message&#39;) 而不是老式的 raise ValueError, &#39;message&#39;，后者已经在 Python 3 中废弃。由于使用了括号，可以避免行连续符的使用。

当捕获异常时，尽可能提及具体的异常而不是使用一个赤裸裸的 except 子句。一个裸露的 except: 子句将捕获 SystemExit 和 KeyboardInterrupt 异常，这样的话就难于使用 control-c 中断程序，并可能掩盖其他问题。如果想要捕获标志程序错误的所有异常的话，用 except Exception:(裸露的 except 子句等同于 except BaseException:)：


1
2
3
4
try:
    import platform_specific_module
except ImportError:
    platform_specific_module &#x3D; None




一个很好的经验法则是将裸露的 except 子句仅用于以下两种情况：  
1、If the exception handler will be printing out or logging the traceback; at least the user will be aware that an error has occurred.
2、If the code needs to do some cleanup work, but then lets the exception propagate upwards with raise . try…finally can be a better way to handle this case.



当对捕获的异常重命名时，使用 2.6 版本引入的语法：

1
2
3
4
try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))



当捕获操作系统错误时，相对于内置的 errno 值，最好是使用 Python 3.3 中介绍的显式异常层次结构。

对于所有的 try&#x2F;except 子句，将 try 子句限制为必需的绝对最小代码量避免隐藏 bug：


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
是：

    try:
        value &#x3D; collection[key]
    except KeyError:
        return key_not_found(key)
    else:
        return handle_value(value)

否：

    try:
        # Too broad!
        return handle_value(collection[key])
    except KeyError:
        # Will also catch KeyError raised by handle_value()
        return key_not_found(key)



特定代码块的本地资源使用 with 语句确保使用后立即释放，不能自动释放的使用 try&#x2F;finally 也可以。

除了申请和释放资源，任何时候都应该使用单独的函数和方法调用 Context managers，例如：


1
2
3
4
5
6
7
8
9
是：

    with conn.begin_transaction():
        do_stuff_in_transaction(conn)

否：

    with conn:
        do_stuff_in_transaction(conn) 



函数返回语句要一致。在一个函数内的所有返回语句要么都返回一个表达式，要么都不返回。如果任何一个返回语句返回了表达式，那么其他任何没有返回值的语句应该明确声明为 return None。在函数结束部分必须出现返回语句：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
是：

    def foo(x):
        if x &gt;&#x3D; 0:
            return math.sqrt(x)
        else:
            return None
    
    def bar(x):
        if x &lt; 0:
            return None
        return math.sqrt(x)

否：

    def foo(x):
        if x &gt;&#x3D; 0:
            return math.sqrt(x)
    
    def bar(x):
        if x &lt; 0:
            return
        return math.sqrt(x)

相对于 string 模块，使用 string 方法要快的多并且与 unicode strings 共享相同的 API。当然了，除了需要考虑 2.0 版本之前 python 代码向后兼容性的情况。

使用 ‘’.startswith() 和 ‘’.endswith() 而不是字符串切片来检查前缀或后缀，例如：


1
2
是： if foo.startswith(&amp;#x27;bar&amp;#x27;):
否： if foo[:3] &#x3D;&#x3D; &amp;#x27;bar&amp;#x27;:



对象类型比较应该使用isinstance() 而不是直接比较：

1
2
是： if isinstance(obj, int):
否： if type(obj) is type(1):


当检查一个对象是否为字符串时，一定要注意这个对象也可能是 unicode 字符串！在 Python 2 中，string 和 unicode 拥有一个公共基类 basestring，因此可以这么的：
1
if isinstance(obj, basestring):


在 Python 3 中，unicode 和 basestring 已然不复存在(there’s only str)，并且 bytes object 也不再视为一种 string 了，而是一个整形序列。

对于序列（字符串，列表，元组）的判空操作：
1
2
3
4
5
6
7
是：
    if not seq:
    if seq:

否：
    if len(seq):
    if not len(seq):

不要使用尾随空格。

不要使用 &#x3D;&#x3D; 验证布尔值为 Ture 或 False：


1
2
3
4
5
6
是：
      if greeting:
否：
      if greeting &#x3D;&#x3D; True:
虾扯蛋：
      if greeting is True:


</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5.1"><span class="toc-number">1.7.1.</span> <span class="toc-text">心理藏的小烦恼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5.2"><span class="toc-number">1.7.2.</span> <span class="toc-text">其他建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6"><span class="toc-number">1.8.</span> <span class="toc-text">何时使用逗号结尾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7"><span class="toc-number">1.9.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7.1"><span class="toc-number">1.9.1.</span> <span class="toc-text">块注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7.2"><span class="toc-number">1.9.2.</span> <span class="toc-text">行注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7.3"><span class="toc-number">1.9.3.</span> <span class="toc-text">文档字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8"><span class="toc-number">1.10.</span> <span class="toc-text">命名约定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8.1"><span class="toc-number">1.10.1.</span> <span class="toc-text">圣经戒律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.2"><span class="toc-number">1.10.2.</span> <span class="toc-text">描述性: 命名风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8.3"><span class="toc-number">1.10.3.</span> <span class="toc-text">规定性: 命名习惯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.1"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">避免的命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.2"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">包和模块名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.3"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">类名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.4"><span class="toc-number">1.10.3.4.</span> <span class="toc-text">类型变量名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.5"><span class="toc-number">1.10.3.5.</span> <span class="toc-text">异常名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.6"><span class="toc-number">1.10.3.6.</span> <span class="toc-text">全局变量名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.7"><span class="toc-number">1.10.3.7.</span> <span class="toc-text">函数名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.8"><span class="toc-number">1.10.3.8.</span> <span class="toc-text">函数和方法参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.9"><span class="toc-number">1.10.3.9.</span> <span class="toc-text">方法名和实例变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.10"><span class="toc-number">1.10.3.10.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.11"><span class="toc-number">1.10.3.11.</span> <span class="toc-text">继承设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8.3.12"><span class="toc-number">1.10.3.12.</span> <span class="toc-text">公共和内部接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9"><span class="toc-number">1.10.4.</span> <span class="toc-text">编码建议</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/01/TODO-2023/2023-01-02-TODO-2023/" title="TODO 2023">TODO 2023</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/02/27/00-Python/Python100%E4%BE%8B/" title="python100例">python100例</a><time datetime="2020-02-27T08:55:31.000Z" title="发表于 2020-02-27 16:55:31">2020-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/02/27/00-Python/Python110%E9%81%93%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Python 110道基础笔试题">Python 110道基础笔试题</a><time datetime="2020-02-27T08:55:31.000Z" title="发表于 2020-02-27 16:55:31">2020-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/02/27/00-Python/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%AE%97%E6%B3%95%E5%B2%97/" title="算法岗面试题">算法岗面试题</a><time datetime="2020-02-27T08:55:31.000Z" title="发表于 2020-02-27 16:55:31">2020-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/02/27/00-Python/python%E9%9D%A2%E8%AF%95%E9%A2%98/" title="python面试">python面试</a><time datetime="2020-02-27T08:55:31.000Z" title="发表于 2020-02-27 16:55:31">2020-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By WinkyQin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div></div></body></html>